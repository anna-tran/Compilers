
module SkelM where

-- Haskell module generated by the BNF converter

import AbsM
import ErrM
import AstM as A
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transTokenID :: TokenID -> String
transTokenID x = case x of
  TokenID string -> string
transTokenReal :: TokenReal -> Float
transTokenReal x = case x of
  TokenReal string -> (read string :: Float)

transTokenInt :: TokenInt -> Integer
transTokenInt x = case x of
  TokenInt string -> (read string :: Integer)

transProg :: Prog -> A.M_prog
transProg x = case x of
  Prog block -> A.M_prog (transBlock block)

transBlock :: Block -> ([A.M_decl],[A.M_stmt])
transBlock x = case x of
  Block decls progbody -> ((transDecls decls),(transProgBody progbody))

transDecls :: Decls -> [A.M_decl]
transDecls x = case x of
  DeclDecls decl decls -> ((transDecl decl):(transDecls decls))
  NoDecls -> []


transDecl :: Decl -> M_decl
transDecl x = case x of
  VarDecl vardecl -> A.M_var (transVarDecl vardecl)
  FunDecl fundecl -> A.M_fun (transFunDecl fundecl)

transVarDecl :: VarDecl -> (String,[A.M_expr], A.M_type)
transVarDecl x = case x of
  MVar tokenid arrdim type_ -> (id,ad,t)
            where
                id = transTokenID tokenid
                ad = transArrDim arrdim
                t = transType type_

transType :: Type -> A.M_type
transType x = case x of
  MInt -> A.M_int
  MReal -> A.M_real
  MBool -> A.M_bool

transArrDim :: ArrDim -> [A.M_expr]
transArrDim x = case x of
  ExprArrDim expr arrdim -> ((transExpr expr):(transArrDim arrdim))
  NoArrDim -> []
transFunDecl :: FunDecl -> (String,[(String,Int,A.M_type)],A.M_type,[A.M_decl],[A.M_stmt])
transFunDecl x = case x of
  MFun tokenid paramlist type_ funblock -> ((transTokenID tokenid), 
                                              (transParamList paramlist), 
                                              (transType type_),
                                              decls,
                                              stmts)
      where
        (decls, stmts)= (transFunBlock funblock)


transFunBlock :: FunBlock -> ([A.M_decl],[A.M_stmt])
transFunBlock x = case x of
  DeclFunBody decls funbody -> ((transDecls decls), (transFunBody funbody))

transParamList :: ParamList -> [(String,Int,A.M_type)]
transParamList x = case x of
  Params params -> transParams params

transParams :: Params -> [(String,Int,A.M_type)]
transParams x = case x of
  DeclMoreParams basicdecl moreparams -> ((transBasicDecl basicdecl):(transMoreParams moreparams))
  NoParams -> []

transMoreParams :: MoreParams -> [(String,Int,A.M_type)]
transMoreParams x = case x of
  CommaDeclMoreParams basicdecl moreparams -> ((transBasicDecl basicdecl):(transMoreParams moreparams))
  NoMoreParams -> []

transBasicDecl :: BasicDecl -> (String,Int,A.M_type)
transBasicDecl x = case x of
  BasicDecl tokenid basicarraydim type_ -> ((transTokenID tokenid),
                                            (transBasicArrayDim basicarraydim),
                                            (transType type_))




transBasicArrayDim :: BasicArrayDim -> Int
transBasicArrayDim x = case x of
  BasicArrDim solidparen basicarraydim -> ((transSolidParen solidparen) + (transBasicArrayDim basicarraydim))
  NoBasicArrDim -> 0
transSolidParen :: SolidParen -> Int
transSolidParen x = case x of
  SolidParen -> 1




transProgBody :: ProgBody -> [A.M_stmt]
transProgBody x = case x of
  ProgStmtsBody progstmts -> transProgStmts progstmts

transFunBody :: FunBody -> [A.M_stmt]
transFunBody x = case x of
  FunBody progstmts expr -> ((transProgStmts progstmts) ++ [(A.M_return (transExpr expr))])

transProgStmts :: ProgStmts -> [A.M_stmt]
transProgStmts x = case x of
  ProgStmts stmt progstmts -> ((transStmt stmt) : (transProgStmts progstmts))
  NoProgStmts -> []
transStmt :: Stmt -> A.M_stmt
transStmt x = case x of
  MCond expr stmt1 stmt2 -> A.M_cond (e,s1,s2)
            where
                e = transExpr expr
                s1 = transStmt stmt1
                s2 = transStmt stmt2
  MWhile expr stmt -> A.M_while (e,s1)
            where
                e = transExpr expr
                s1 = transStmt stmt
  MRead identifier -> A.M_read (str,exprList)
            where
                (str,exprList) = (transIdentifier identifier)
  MAss identifier expr -> A.M_ass (str, exprList, e)
            where
                e = (transExpr expr)
                (str, exprList) = (transIdentifier identifier)
  MPrint expr -> A.M_print (transExpr expr)
  MBlock block -> A.M_block (transBlock block)

transIdentifier :: Identifier -> (String,[A.M_expr])
transIdentifier x = case x of
  MId tokenid arrdim -> (id, ad)
            where
                id = transTokenID tokenid
                ad = transArrDim arrdim

transExpr :: Expr -> A.M_expr 
transExpr x = case x of
  ExprBintTerm expr bintterm -> A.M_app (M_or, ([e] ++ [bt]))
            where
                e = transExpr expr
                bt = transBintTerm bintterm
  BintTerm bintterm -> transBintTerm bintterm


transBintTerm :: BintTerm -> A.M_expr 
transBintTerm x = case x of
  BintTermBintFactor bintterm bintfact -> A.M_app (M_and, ([bt] ++ [bf]))
            where
                bt = transBintTerm bintterm
                bf = transBintFact bintfact
  BintFactor bintfact -> transBintFact bintfact


transBintFact :: BintFact -> A.M_expr
transBintFact x = case x of
  NotBintFactor bintfact -> A.M_app (M_not, [bf])
            where
                bf = transBintFact bintfact
  IntECompareIntE intexpr1 compareop intexpr2 -> A.M_app (op, ([e1] ++ [e2]))
            where
                op = transCompareOp compareop
                e1 = transIntExpr intexpr1
                e2 = transIntExpr intexpr2
  IntE intexpr -> transIntExpr intexpr

transCompareOp :: CompareOp -> A.M_operation
transCompareOp x = case x of
  MEq -> A.M_eq
  MLt -> A.M_lt
  MGt -> A.M_gt
  MLe -> A.M_le
  MGe -> A.M_ge




transIntExpr :: IntExpr -> A.M_expr
transIntExpr x = case x of
  IntEAddIntT intexpr addop intterm -> A.M_app (op, ([ie] ++ [it]))
                where
                    op = transAddOp addop
                    ie = transIntExpr intexpr
                    it = transIntTerm intterm

  IntT intterm -> transIntTerm intterm

transAddOp :: AddOp -> A.M_operation
transAddOp x = case x of
  MAdd -> A.M_add
  MSub -> A.M_sub

transIntTerm :: IntTerm -> A.M_expr
transIntTerm x = case x of
  IntTMulIntF intterm mulop intfactor -> A.M_app (op, ([it] ++ [intf]))
                where
                    op = transMulOp mulop
                    it = transIntTerm intterm
                    intf = transIntFactor intfactor

  IntF intfactor -> transIntFactor intfactor

transMulOp :: MulOp -> A.M_operation
transMulOp x = case x of
  MMul -> A.M_mul
  MDiv -> A.M_div

transIntFactor :: IntFactor -> A.M_expr
transIntFactor x = case x of
  EnclosedExpr expr -> transExpr expr
  MSize tokenid basicarraydim -> A.M_size (id,arrDim)
                where
                    id = (transTokenID tokenid)
                    arrDim = (transBasicArrayDim basicarraydim)
  MFloat expr -> A.M_app (A.M_float, [(transExpr expr)])
  MFloor expr -> A.M_app (A.M_floor, [(transExpr expr)])
  MCeil expr -> A.M_app (A.M_ceil, [(transExpr expr)])
  Id_modlist tokenid modifierlist -> transModifierList id modifierlist
                where
                  id = (transTokenID tokenid)
  MIval tokenint -> A.M_ival (transTokenInt tokenint)
  MRval tokenreal -> A.M_rval (transTokenReal tokenreal)
  MBval mbool -> A.M_bval (transMbool mbool)
  MNval intfactor -> A.M_app (A.M_neg, [intf])
                where 
                    intf = transIntFactor intfactor

transMbool :: Mbool -> Bool
transMbool x = case x of
  NoTrue -> True
  NoFalse -> False


transModifierList :: String -> ModifierList -> A.M_expr
transModifierList id x = case x of
  EnclosedArgs args -> A.M_app ((A.M_fn id), exprs)
                where
                    exprs = (transArgs args)
  ArrDim arrdim -> A.M_id (id, exprs)
                where
                    exprs = (transArrDim arrdim)

transArgs :: Args -> [A.M_expr]
transArgs x = case x of
  MoreArgs expr moreargs -> ((transExpr expr):(transMoreArgs moreargs))
  NoArgs -> []
transMoreArgs :: MoreArgs -> [A.M_expr]
transMoreArgs x = case x of
  ExprMoreArgs expr moreargs -> ((transExpr expr):(transMoreArgs moreargs))
  NoMoreArgs -> []



