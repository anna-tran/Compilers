-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParM where
import AbsM
import LexM
import ErrM

}

%name pProg Prog
%name pBlock Block
%name pDecls Decls
%name pDecl Decl
%name pVarDecl VarDecl
%name pType Type
%name pArrDim ArrDim
%name pFunDecl FunDecl
%name pFunBlock FunBlock
%name pParamList ParamList
%name pParams Params
%name pMoreParams MoreParams
%name pBasicDecl BasicDecl
%name pBasicArrayDim BasicArrayDim
%name pSolidParen SolidParen
%name pProgBody ProgBody
%name pFunBody FunBody
%name pProgStmts ProgStmts
%name pStmt Stmt
%name pIdentifier Identifier
%name pExpr Expr
%name pBintTerm BintTerm
%name pBintFact BintFact
%name pCompareOp CompareOp
%name pIntExpr IntExpr
%name pAddOp AddOp
%name pIntTerm IntTerm
%name pMulOp MulOp
%name pIntFactor IntFactor
%name pMbool Mbool
%name pModifierList ModifierList
%name pArgs Args
%name pMoreArgs MoreArgs
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '&&' { PT _ (TS _ 1) }
  '(' { PT _ (TS _ 2) }
  ')' { PT _ (TS _ 3) }
  '*' { PT _ (TS _ 4) }
  '+' { PT _ (TS _ 5) }
  ',' { PT _ (TS _ 6) }
  '-' { PT _ (TS _ 7) }
  '/' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  ':=' { PT _ (TS _ 10) }
  ';' { PT _ (TS _ 11) }
  '<' { PT _ (TS _ 12) }
  '<=' { PT _ (TS _ 13) }
  '=' { PT _ (TS _ 14) }
  '>' { PT _ (TS _ 15) }
  '>=' { PT _ (TS _ 16) }
  '[' { PT _ (TS _ 17) }
  ']' { PT _ (TS _ 18) }
  'begin' { PT _ (TS _ 19) }
  'bool' { PT _ (TS _ 20) }
  'ceil' { PT _ (TS _ 21) }
  'do' { PT _ (TS _ 22) }
  'else' { PT _ (TS _ 23) }
  'end' { PT _ (TS _ 24) }
  'false' { PT _ (TS _ 25) }
  'float' { PT _ (TS _ 26) }
  'floor' { PT _ (TS _ 27) }
  'fun' { PT _ (TS _ 28) }
  'if' { PT _ (TS _ 29) }
  'int' { PT _ (TS _ 30) }
  'not' { PT _ (TS _ 31) }
  'print' { PT _ (TS _ 32) }
  'read' { PT _ (TS _ 33) }
  'real' { PT _ (TS _ 34) }
  'return' { PT _ (TS _ 35) }
  'size' { PT _ (TS _ 36) }
  'then' { PT _ (TS _ 37) }
  'true' { PT _ (TS _ 38) }
  'var' { PT _ (TS _ 39) }
  'while' { PT _ (TS _ 40) }
  '{' { PT _ (TS _ 41) }
  '||' { PT _ (TS _ 42) }
  '}' { PT _ (TS _ 43) }

L_TokenID { PT _ (T_TokenID $$) }
L_TokenReal { PT _ (T_TokenReal $$) }
L_TokenInt { PT _ (T_TokenInt $$) }


%%

TokenID    :: { TokenID} : L_TokenID { TokenID ($1)}
TokenReal    :: { TokenReal} : L_TokenReal { TokenReal ($1)}
TokenInt    :: { TokenInt} : L_TokenInt { TokenInt ($1)}

Prog :: { Prog }
Prog : Block { AbsM.Prog $1 }
Block :: { Block }
Block : Decls ProgBody { AbsM.Block $1 $2 }
Decls :: { Decls }
Decls : Decl ';' Decls { AbsM.DeclDecls $1 $3 }
      | {- empty -} { AbsM.NoDecls }
Decl :: { Decl }
Decl : VarDecl { AbsM.VarDecl $1 } | FunDecl { AbsM.FunDecl $1 }
VarDecl :: { VarDecl }
VarDecl : 'var' TokenID ArrDim ':' Type { AbsM.MVar $2 $3 $5 }
Type :: { Type }
Type : 'int' { AbsM.MInt }
     | 'real' { AbsM.MReal }
     | 'bool' { AbsM.MBool }
ArrDim :: { ArrDim }
ArrDim : '[' Expr ']' ArrDim { AbsM.ExprArrDim $2 $4 }
       | {- empty -} { AbsM.NoArrDim }
FunDecl :: { FunDecl }
FunDecl : 'fun' TokenID ParamList ':' Type '{' FunBlock '}' { AbsM.MFun $2 $3 $5 $7 }
FunBlock :: { FunBlock }
FunBlock : Decls FunBody { AbsM.DeclFunBody $1 $2 }
ParamList :: { ParamList }
ParamList : '(' Params ')' { AbsM.Params $2 }
Params :: { Params }
Params : BasicDecl MoreParams { AbsM.DeclMoreParams $1 $2 }
       | {- empty -} { AbsM.NoParams }
MoreParams :: { MoreParams }
MoreParams : ',' BasicDecl MoreParams { AbsM.CommaDeclMoreParams $2 $3 }
           | {- empty -} { AbsM.NoMoreParams }
BasicDecl :: { BasicDecl }
BasicDecl : TokenID BasicArrayDim ':' Type { AbsM.BasicDecl $1 $2 $4 }
BasicArrayDim :: { BasicArrayDim }
BasicArrayDim : SolidParen BasicArrayDim { AbsM.BasicArrDim $1 $2 }
              | {- empty -} { AbsM.NoBasicArrDim }
SolidParen :: { SolidParen }
SolidParen : '[' ']' { AbsM.SolidParen }
ProgBody :: { ProgBody }
ProgBody : 'begin' ProgStmts 'end' { AbsM.ProgStmtsBody $2 }
FunBody :: { FunBody }
FunBody : 'begin' ProgStmts 'return' Expr ';' 'end' { AbsM.FunBody $2 $4 }
ProgStmts :: { ProgStmts }
ProgStmts : Stmt ';' ProgStmts { AbsM.ProgStmts $1 $3 }
          | {- empty -} { AbsM.NoProgStmts }
Stmt :: { Stmt }
Stmt : 'if' Expr 'then' Stmt 'else' Stmt { AbsM.MCond $2 $4 $6 }
     | 'while' Expr 'do' Stmt { AbsM.MWhile $2 $4 }
     | 'read' Identifier { AbsM.MRead $2 }
     | Identifier ':=' Expr { AbsM.MAss $1 $3 }
     | 'print' Expr { AbsM.MPrint $2 }
     | '{' Block '}' { AbsM.MBlock $2 }
Identifier :: { Identifier }
Identifier : TokenID ArrDim { AbsM.MId $1 $2 }
Expr :: { Expr }
Expr : Expr '||' BintTerm { AbsM.ExprBintTerm $1 $3 }
     | BintTerm { AbsM.BintTerm $1 }
BintTerm :: { BintTerm }
BintTerm : BintTerm '&&' BintFact { AbsM.BintTermBintFactor $1 $3 }
         | BintFact { AbsM.BintFactor $1 }
BintFact :: { BintFact }
BintFact : 'not' BintFact { AbsM.NotBintFactor $2 }
         | IntExpr CompareOp IntExpr { AbsM.IntECompareIntE $1 $2 $3 }
         | IntExpr { AbsM.IntE $1 }
CompareOp :: { CompareOp }
CompareOp : '=' { AbsM.MEq }
          | '<' { AbsM.MLt }
          | '>' { AbsM.MGt }
          | '<=' { AbsM.MLe }
          | '>=' { AbsM.MGe }
IntExpr :: { IntExpr }
IntExpr : IntExpr AddOp IntTerm { AbsM.IntEAddIntT $1 $2 $3 }
        | IntTerm { AbsM.IntT $1 }
AddOp :: { AddOp }
AddOp : '+' { AbsM.MAdd } | '-' { AbsM.MSub }
IntTerm :: { IntTerm }
IntTerm : IntTerm MulOp IntFactor { AbsM.IntTMulIntF $1 $2 $3 }
        | IntFactor { AbsM.IntF $1 }
MulOp :: { MulOp }
MulOp : '*' { AbsM.MMul } | '/' { AbsM.MDiv }
IntFactor :: { IntFactor }
IntFactor : '(' Expr ')' { AbsM.EnclosedExpr $2 }
          | 'size' '(' TokenID BasicArrayDim ')' { AbsM.MSize $3 $4 }
          | 'float' '(' Expr ')' { AbsM.MFloat $3 }
          | 'floor' '(' Expr ')' { AbsM.MFloor $3 }
          | 'ceil' '(' Expr ')' { AbsM.MCeil $3 }
          | TokenID ModifierList { AbsM.Id_modlist $1 $2 }
          | TokenInt { AbsM.MIval $1 }
          | TokenReal { AbsM.MRval $1 }
          | Mbool { AbsM.MBval $1 }
          | '-' IntFactor { AbsM.MNval $2 }
Mbool :: { Mbool }
Mbool : 'true' { AbsM.NoTrue } | 'false' { AbsM.NoFalse }
ModifierList :: { ModifierList }
ModifierList : '(' Args ')' { AbsM.EnclosedArgs $2 }
             | ArrDim { AbsM.ArrDim $1 }
Args :: { Args }
Args : Expr MoreArgs { AbsM.MoreArgs $1 $2 }
     | {- empty -} { AbsM.NoArgs }
MoreArgs :: { MoreArgs }
MoreArgs : ',' Expr MoreArgs { AbsM.ExprMoreArgs $2 $3 }
         | {- empty -} { AbsM.NoMoreArgs }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

